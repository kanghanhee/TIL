### 저장 프로시저 (Stored Procedure)
------------------------------------------------
프로시저라고 불리는 Stored Procedure는 프로그램에서 만들어 놓은 SQL 문을 저장해놓고, 필요할 때마다 호출해서 사용할 수 있도록 각 DBMS에서 제공하는 프로그래밍 기능이다.

stored procedure 는 쿼리문들의 집합으로, 어떤 동작을 여러쿼리를 걸쳐 일괄적으로 처리할 때 사용한다.

굳이 procedure를 사용해야하나 생각했다.

실무에서 프로시저를 사용하는 데에는 몇 가지 이유가 있다.

1. SQL Server 성능 향상
   프로시저를 처음에 실행하면 컴파일 단계를 거쳐 그 결과가 캐시(메모리)에 저장되는데, 이 후 해당 프로시저를 호출하면 캐시에 있는 것을 가져와서 사용하므로 실행속도가 빨라진다.
   따라서 일반 쿼리를 반복해 실행하는 것보다 프로시저를 사용하는 것이 성능적인 측면에서 좋다.

2. 유지보수 Good
   직접 SQL문을 호출하지 않고 저장 프로시저의 이름을 호출하도록 설정해 사용하는 경우가 많은데, 이 때 수정해야할 코드 내의 SQL문을 건드리지 않고 프로시저 파일만 수정하면 되기 때문에 유지보수 측면에서 매우 유리해진다.

3. 보안 강화
   실제 테이블에 접근하여 다양한 조작을 하는 것은 위험하기 때문에 실무에서는 실제로 개발자에게 프로시저 접근 권한만 주는 방식을 많이 사용한다.

### 일반적인 SQL 동작 방식 vs Stored Procedure 동작 방식
----------------------------------------------

```
SELECT * FROM user;
```

위 쿼리를 실행한다고 가정해보자.

먼저 구문 분석 단계에서 구문 자체에 오류가 없는지 분석할 것이다. 만약 오타가 있으면 여기서 오류가 발생되어 에러를 띄울 것이다.

다음은 개체 이름 확인 단계에서 user 테이블이 현재 데이터베이스에 있는지 확인을 한다.

그 다음 사용권환 확인 단계에서 user 테이블에 접근 권한이 있는지를 확인한다.

다음으로 최적화 단계에서 해당 쿼리문이 가장 좋은 성능을 낼 수 있는 경로를 결정한다. 인데스 사용여부에 따라 경로가 결정된다고 보면된다.

다음은 최적화된 결과를 바탕으로 실행계획을 메모리(캐시)에 등록한다.

그리고 컴파일된 결과를 실행한다.

<br>

간단한 쿼리지만 이런 많은 절차를 거친다.

만약 동일한 SQL문을 실행하면 아래와 같이 단순하게 동작하게 된다.
하지만 만약 동일한 쿼리가 캐시메모리에 존재하지 않는다면 위에서 설명한 전체 과정을 다시 반복하게 된다. 여기서 주의할 점은 쿼리 전체가 한글자도 틀리지 않고 같아야 한다는 것이다.

`프로시저 동작 방식`
----------------------------------------------------
<br>
먼저 Stored Procedure를 정의했을 때의 동작방식부터 알아보겠다.

일단 먼저 해당 프로시저에 구문 오류가 있는지 분석한다.

다음은 `지연된 이름 확인(deferred name resolution)` 과정을 거치는데 이는 프로시저의 특징 중 하나이다.
프로시저의 경우 프로시저를 정의하는 시점에 테이블과 같은 개체의 존재여부와 상관없이 정의가 가능한데, 그 이유는 테이블의 존재 여부를 프로시저의 실행 시점에 확인하기 때문이다. 그래서 테이블의 존재 여부와 상관없이 프로시저를 정의할 수 있다. 그런데 테이블의 열이름이 틀리면 오류가 발생된다.

다음은 사용자가 프로시저를 생성할 권한이 있는지 확인을 한다.

마지막으로 시스템 테이블 등록을 진행한다. 프로시저의 이름과 코드가 관련 시스템 테이블에 등록되는 과정이다.

그렇다면 Stored Procedure의 동작 방식은 어떨까?

일반적인 쿼리를 수행하는 방식과 비슷하지만 프로시저 정의 단계에서 구문분석은 끝났지 때문에 따로 구문분석을 하지는 않는다.
위에서 프로시저 정의할 때 지연된 이름 확인이란 절차가 있었는데, 실제로 해당 개체가 유효한지 `개체 이름 확인` 단계에서 진행한다. 다시 말해 프로시저의 실행 시에만 해당 개체가 존재하면 실행이 되는 것이다.
그 이후 단계는 일반적인 쿼리를 돌렸을 때와 비슷한 단계를 거친다.

이 후 실행부터는 메모리에 있는 것을 가져와 재사용할 수 있어 수행시간이 많이 단축된다.

```sql
SELECT * FROM user WHERE name ='이승기';
SELECT * FROM user WHERE name ='성시경';
SELECT * FROM user WHERE name ='은지원';
```

앞서 일반적인 쿼리는 한글자라도 다르면 다른 쿼리로 인식한다고 했다. 때문에 위 쿼리들은 where의 조건 값만 다를 뿐인데 매번 최적화와 컴파일을 다시 수행해야한다.

```sql
CREATE PROCEDURE get_user_name
        @Name VARCHAR(10)
BEGIN
        SELECT * FROM user WHERE name = @name;
END;
```

```sql
CALL get_user_name '이승기'
CALL get_user_name '성시경'
CALL get_user_name '은지원'
```

이렇게 프로시저를 사용하면 이승기를 검색하는 과정에서만 최적화, 컴파일을 수행하고 나머지는 메모리에 있는것을 사용하면 된다. 실제로 다른 것들의 경과시간이 0ms 였다.

결론 : 자주쓰는 쿼리라면 일반 쿼리를 여러 개 날리는 것보다 저장 프로시저를 쓰는게 성능에 좋다!
